面试一般在50min

# Part1-自我介绍【1-2min】

>1. 礼貌
>2. 学历
>3. 身份：工作几年，gap期间干了什么
>4. 紧扣jd项目相关性+技术点介绍❎
>5. 自我优势
>6. 为什么来。eg：公司吸引力【业务、个人爱好、价值观、不谈钱】、地点❎

​	面试官您好，我叫xxx，毕业于211院校南昌大学计算机专业。我做前端已经两年了。

​	（暂定：在空窗期期间，我和朋友一起写了一些H5页面和后台管理系统项目，把它上传到了阿里云，也学习了计算机网络相关的知识。）

​	主要的技术栈是vue3+ts+vite同时也做过electron桌面端和音视频处理的复杂项目。我能够把复杂链路真正跑通，做出可量化工程收益。

​	在内容平台上，我负责把网页端的能力通过桌面端的深度链路进行打通，桌面端用ipc和事件总线event bus把重的任务和ui进行解耦。	利用ffmpeg和hls实现边录边播，支持录制过程中持续更新m3u8，让我对异步稳定性和性能有扎实的理解和突破。	工程效率上主导了vue2到vue3的迁移，构建速度提升了2倍，优化ci/cd项目部署，整体时间压缩到5min，让团队发布节奏更加便捷。

​	（暂定：并且我对xxxx的理念十分认同，所以希望能够成为公司的一员。）

# 转折点：问面试官：是否由我来扩展的讲一下我的项目亮点？【口语化】

# Part2-项目亮点【5min】

>STAR法则
>
>S：背景
>
>T：任务、职责
>
>A：行动，eg：踩过的坑、做什么事情、选什么技术、为什么选这个技术、重构的项目做的优化、突破哪些技术瓶颈【提一下但不深挖】
>
>R：结果，突出贡献/业务提升/用户体验

## 亮点1：electron桌面端把网页平台到本地的工具链打通，并且实现ffmpeg+hls的边录边播功能

S：视频分析器的业务中需要从数据网页平台唤起桌面应用并导入指定数据，桌面端再通过ffmpeg和文件系统，对数据进行处理，比如视频和字幕处理、文件导入导出等全过程的解决方案

T：为了实现m3u8/hls直播流拉取录制功能

A：1.关于深度链接：注册桌面端协议，让网页通过链接一键唤起应用并携带参数，导入指定数据进行处理，保证同一链路重复点击的幂等处理

>幂等处理是指 **同一个操作被执行一次或多次，对系统产生的结果是完全相同的**

​	2.ipc和事件总线的解耦：让渲染进程只负责交互和展示，主进程负责ffmpeg和文件系统等io的重的任务，用electron ipc传递状态与进度，用rxjs behaviorSubject做组件间的事件分发，避免模块间得强耦合

>技术拓展
>
>1.render发起业务请求 
>
>2.主进程接收请求后执行重的任务并通过send持续推送进度（在此过程中进行节流，要不然高频次更新会导致页面卡顿）
>
>3.render收到消息之后，汇集到事件中心event bus 
>
> 4.最后让各个ui模块按需订阅，从而实现解耦
>
>
>
>UI组件  → IPC适配器 → IPC通道 → 主进程
>主进程 → IPC通道 → IPC适配器 → 事件总线 → UI组件

​	3.hls边录边播：实时拉取m3u8，动态生成ts切片并把直播切片写到本地，进行增量更新，让播放器播放本地m3u8文件。在录制结束之后，自动生成标准、可回放文件。

>技术拓展
>
>1.hls边录边播本质是实现镜像同步，定期拉取远程m3u8，如果有新的ts片段，就下载到本地，进行增量更新，播放器播放本地m3u8文件进行播放 
>
>2.码率统一处理。使用FFmpeg将不同码率的切片转码为统一规格，保证参数的一致性。
>
>3.拉取过程出现问题。
>
>​	a.切片唯一标识。用ts切片的精确元数据，如开始、持续时间等关键信息配合时间戳组合生成切片唯一标识。
>
>​	b.本地比较与去重。建立已下载切片索引JSON文件，检查文件大小，大小不匹配删除重新下载，避免重复下载
>
>​	c.失败处理。
>
>​		判断失败类型是否应该重试
>
>​		如果是可恢复错误，如网络异常等设置重试次数，进入重试队列并删除旧切片。在重试队列中下载失败，删除错误切片，切片索引文件设置错误状态，给用户提示错误信息，等待用户主动选择断点续传
>
>​		如果是不可恢复错误，删除失败切片，标记失败状态，给用户提示失败信息
>
>​	d.断点续传：
>
>- 读取已下载切片索引JSON文件，获取已下载的切片列表
>- 请求m3u8文件，获取最新的切片列表
>- 对比两个切片列表，来计算缺少的切片
>- 下载缺失的切片，更新本地记录
>
>4.录制结束封装标准文件mp4，清理临时文件，突破平台限制，便于用户使用
>
>【补】踩过的坑：
>
>为了实现边录边播一开始选择的方案是将直播流切片直接输出为mp4文件，但是发现切片时间很难确定。切片时间过短会导致mp4文件包含重复的`元数据头`，在播放中会出现卡顿并且会有时间误差；切片时间过长又不满足实时的需求，因此放弃了这种方案

R：开发了一个专业级跨平台桌面应用，解决了视频分析业务中从云端协同到本地的难点

## 亮点2： Vue3 + Vite 迁移 + 表格性能体系

S：因为篮球技战术服务平台页面耦合度比较高，工程老旧，数据查询交互频繁，所以进行了vue3+Vite迁移在这个背景下

T：这个项目我作为负责人从0到1进行开发，完成技术栈升级，提高开发效率和运行体验、解决大数据量的表格不卡顿，并且完成三端适配

> 基础样式 (手机) → sm: (小平板) → md: (平板) → lg: (桌面) → xl: (大屏)
>
> 响应式怎么实现
>
> 这个项目是使用媒体查询的方式，但是如果重新做的话，我会选择使用tailwind css。因为`tailwind css`采用原子化的css方式，可以直接通过类名组合实现样式编写，避免了传统的css编写、维护负担，代码可读性更好、也更容易维护，并且在不同前端框架之间进行样式迁移的成本更低。另外，采用了移动端优先的设计理念，更符合现在的开发习惯，采用一致的断点系统，避免了传统媒体查询中可能出现的断点混乱的问题，可以极大地提高开发效率。

A：1.工程升级：vue2+vue cli到vue3+vite，让项目更加清晰化、模块化、组件化。

​		2.状态与组件体系的重构：vuex到pinia。将高耦合页面拆分为复用组件，降低了维护成本。

​		3.性能策略：查询加防抖，降低多参数联动造成的请求风暴；实现前端分页、排序、筛选，减少用户等待和交互的时间成本；采用table-layout: fixed + rowKey，表格渲染用固定高度的滚动容器+虚拟渲染来控制渲染窗口，实现滚动不卡顿的效果；设计可配置管道，提供钩子函数让父组件定制处理逻辑

R：构建速度提升65%，开发体验和运行效果得到显著改善，确保千行数据表格场景可以更加顺畅滚动

## 亮点3：开发交互式数字报告阅读器

开发交互式数字报告阅读器，使用IntersectionObserver通过动态缓冲区，实现智能懒加载；

S：数字报告内容长，是一个多页结构，全量加载会导致首屏加载慢，内存占用高，快速滚动会出现白屏现象

T：为解决这个问题保证滚动顺滑的同时控制内存进行智能加载

A：我基于IntersectionObserver进行可视区探测，设计动态缓存区域，根据实际页面高度计算加载窗口，默认对可视区域上下各缓存3页，在滚动中过程中动态调整加载和回收边界，平衡了加载速度和内存

R：这样就实现长报告场景的智能懒加载，避免一次性渲染，带来的性能问题，减少了滚动空白、卡顿问题

# part3项目拓展（你了解什么）

## electron项目

问题1：深度链接方面如何通过自定义协议来保证安全、幂等、跨平台一致性

要点：

1. Windows、linux、macos三平台，注册方式的有什么差异，安装升级方面的更新策略
2. 幂等：导入任务hashkey重复点击，只会聚焦在窗口，然后复用任务
3. 参数校验逻辑：白名单、域、内外部信息源也要做信息校验，控制边界，做到权限边界最小暴露，比如id、url、path做检查、长度校验
4. 签名和一次性token，深度链接携带signature，桌面端通过共享密钥进行验迁，校验过期时间防止伪造或重放（数据完整度）。权限最小化只允许触发导入任务，不允许其他命令

>在实现跨平台深度链接的安全方案中，首先建立了统一的协议注册机制：Windows通过注册表、macOS通过Info.plist、Linux通过.desktop文件，并在安装升级时确保协议处理器的原子性更新。为实现幂等性，我们基于参数内容生成唯一HashKey，通过全局任务管理中心实现重复点击时自动窗口聚焦和任务复用，避免资源浪费。安全层面采用多层防御：第一层是白名单校验，严格限制可执行的命令和参数格式；第二层是边界控制，对ID、URL、Path进行长度和格式校验；第三层是数字签名机制，深度链接携带时效性签名和一次性Token，客户端通过共享密钥验签并防重放攻击，同时严格控制权限边界，深度链接仅能触发导入任务，无法执行其他敏感操作，所有操作都在沙箱环境中运行并记录完整审计日志，实现了安全、幂等与体验的平衡。

问题2：关于ipc的性能和阻塞，ffmpeg产生日志输出，频繁通过ipc配送到渲染进程，导致页面掉帧，怎么做日志截流

>1. 数据源进行优化。对日志信息进行处理，过滤掉冗余信息，压缩合并日志信息，来减少数据量
>2. 进行分级传输。建立优先级系统，优先传输错误、警告等高优先级日志信息，将普通信息日志进行节流批量发送。建立两个数据传输通道，一个实时通道用于传输高优先级，一个批量通道用于传输低优先级。在用户交互频繁时，自动降低日志频率。
>3. 将ipc和事件总线进行解耦，通过rxjs behaverSubject进行组件间的时间分发，让组件按需订阅，避免不必要的数据处理和渲染
>4. 渲染进程使用`requestAnimationFrame`来调度渲染，避免阻塞主线程。同时实现虚拟化列表，只渲染可视区域的日志，并且限制最大显示数量
>
>注：`requestAnimationFrame` 是浏览器提供的一个**高性能动画 API**，专门用来调度下一帧的渲染更新。告诉浏览器：“在下一次重绘之前执行这个回调函数”。这样代码执行就与浏览器的刷新率（通常是 60Hz，即每 16.7ms 一帧）完全同步。



问题3：hls边录边播的具体实现

> hls落地（目标-》请求入口到m3u8【多码率问题】，循环拉取m3u8，循环间隔【5s】、录的那个playlist）时间戳、封装、断流[顺序，]
>
> 下载更新、segments 列表【去重，错误，对比，并发控制（2-3个）网络拉爆，】
>
> m3u8增量更新的坑：
>
> 1. 直播滑动窗口晚抓丢片（轮训间隔、当前网络情况，切片缺失问题）
> 2. 下载过程中数据加密hls
> 3. 重写m3u8读写竞争，播放器缓存
> 4. 写入一半的不播，
> 5. 断流抖动处理、重试策略【2-3次重试次数，看一下代码 => 重试次数】
>
> 切片缺失跳过切片去播

## vue3+vite迁移+表格性能

问题1：迁移是渐进还是一次性的，做回滚【如何做渐进式迁移】

> 回滚
>
> 1. 渐进式迁移，一次性风险大，回滚成本高
> 2. 先做底座（建项目骨架，构建规范，公共工具请求体、基础组件迁移）
> 3. 按照路由、业务以页面入口做单位迁移，没迁移一个模块做测试
> 4. 新旧并存，删除过渡文件
>
> 
>
> 灰度发布
>
> 1. 配置灰度人群
> 2. 测试人员+客服
> 3. 监控性能：错误率、成功绿，白屏，长任务，接口异常，JS error
>
> 
>
> - 灰度出现问题，要有回滚预案，v2-》v3。版本切换，根据路径切换资源
>
> - 构建产物，双版本，保留旧版本-》回滚切换入口。（包冗余过大），
>
> - 接口、数据接口兼容问题。兼容数据结构（双向）

问题2：构建提速来源于哪里

>`vite和webpack`区别，打包工具对比
>
>vite用esbuild，go写的运行快，打的依赖高效缓存，首次启动预构建缓存，后续用缓存，大的项目差异越明显
>
>vue2+webpack的dev，打包esm 按需编译
>
>工程化
>
>组件库按需引用，减少编译压力，动态import，分包策略，缓存策略（vite cache）
>
>证明65%，开发冷启动事件，热更新时间

问题3：表格虚拟滚动

> requestAnimationFrame
>
> 1. 目标（）
> 2. 固定高度滚动容器overflow，窗口计算记载在可视窗口的元素，数据缓存&回收
> 3. rAF和settimeout，setinterval比较，raf的优势，浏览器真的循环（点击，js执行，raf回到执行）
> 4. raf绘制过程，
> 5. `raf如何实现节流`&代码实现

## 阅读器

`IntersectionObserver`怎么做的，生命周期，观察对象怎么设计

喜欢的公司定位一下，

1. 包体积



# 其他

1. 可量化工程收益
   - 技术上：ab测试、监控面板、lighthouse进行量化恒定
   - 非技术：我主观的感受
2. 禁语
   - 钱
   - 不会/没做过
     - 我从技术原理推断应该xxx做的